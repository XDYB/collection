(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./src sync recursive":
/*!******************!*\
  !*** ./src sync ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./src sync recursive\";\n\n//# sourceURL=webpack:///./src_sync?");

/***/ }),

/***/ "./src/binding.js":
/*!************************!*\
  !*** ./src/binding.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n *  Binding class.\n *\n *  each property on the viewmodel has one corresponding Binding object\n *  which has multiple directive instances on the DOM\n *  and multiple computed property dependents\n */\nfunction Binding (compiler, key, isExp, isFn) {\n    this.value = undefined\n    this.isExp = !!isExp\n    this.isFn = isFn\n    this.root = !this.isExp && key.indexOf('.') === -1\n    this.compiler = compiler\n    this.key = key\n    this.instances = []\n    this.subs = []\n    this.deps = []\n}\n\nvar BindingProto = Binding.prototype\n\n/**\n *  Process the value, then trigger updates on all dependents\n */\nBindingProto.update = function (value) {\n    this.value = value\n    var i = this.instances.length\n    while (i--) {\n        this.instances[i].update(value)\n    }\n    this.pub()\n}\n\n/**\n *  -- computed property only --    \n *  Force all instances to re-evaluate themselves\n */\nBindingProto.refresh = function () {\n    var i = this.instances.length\n    while (i--) {\n        this.instances[i].refresh()\n    }\n    this.pub()\n}\n\n/**\n *  Notify computed properties that depend on this binding\n *  to update themselves\n */\nBindingProto.pub = function () {\n    var i = this.subs.length\n    while (i--) {\n        this.subs[i].refresh()\n    }\n}\n\n/**\n *  Unbind the binding, remove itself from all of its dependencies\n */\nBindingProto.unbind = function () {\n    var i = this.instances.length\n    while (i--) {\n        this.instances[i].unbind()\n    }\n    i = this.deps.length\n    var subs\n    while (i--) {\n        subs = this.deps[i].subs\n        subs.splice(subs.indexOf(this), 1)\n    }\n}\n\nmodule.exports = Binding\n\n//# sourceURL=webpack:///./src/binding.js?");

/***/ }),

/***/ "./src/compiler.js":
/*!*************************!*\
  !*** ./src/compiler.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Emitter     = __webpack_require__(/*! ./emitter */ \"./src/emitter.js\"),\n    Observer    = __webpack_require__(/*! ./observer */ \"./src/observer.js\"),\n    config      = __webpack_require__(/*! ./config */ \"./src/config.js\"),\n    utils       = __webpack_require__(/*! ./utils */ \"./src/utils.js\"),\n    Binding     = __webpack_require__(/*! ./binding */ \"./src/binding.js\"),\n    Directive   = __webpack_require__(/*! ./directive */ \"./src/directive.js\"),\n    TextParser  = __webpack_require__(/*! ./text-parser */ \"./src/text-parser.js\"),\n    DepsParser  = __webpack_require__(/*! ./deps-parser */ \"./src/deps-parser.js\"),\n    ExpParser   = __webpack_require__(/*! ./exp-parser */ \"./src/exp-parser.js\"),\n    transition  = __webpack_require__(/*! ./transition */ \"./src/transition.js\"),\n    // cache deps ob\n    depsOb      = DepsParser.observer,\n    // cache methods\n    slice       = Array.prototype.slice,\n    log         = utils.log,\n    makeHash    = utils.hash,\n    def         = utils.defProtected,\n    hasOwn      = Object.prototype.hasOwnProperty\n\n/**\n *  The DOM compiler\n *  scans a DOM node and compile bindings for a ViewModel\n */\nfunction Compiler (vm, options) {\n\n    var compiler = this\n\n    // indicate that we are intiating this instance\n    // so we should not run any transitions\n    compiler.init = true\n\n    // extend options\n    options = compiler.options = options || makeHash()\n    utils.processOptions(options)\n    utils.extend(compiler, options.compilerOptions)\n\n    // initialize element\n    var el = compiler.setupElement(options)\n    log('\\nnew VM instance:', el.tagName, '\\n')\n\n    // copy scope properties to vm\n    var scope = options.scope\n    if (scope) utils.extend(vm, scope, true)\n\n    compiler.vm  = vm\n    def(vm, '$', makeHash())\n    def(vm, '$el', el)\n    def(vm, '$compiler', compiler)\n\n    // keep track of directives and expressions\n    // so they can be unbound during destroy()\n    compiler.dirs = []\n    compiler.exps = []\n    compiler.childCompilers = [] // keep track of child compilers\n    compiler.emitter = new Emitter() // the emitter used for nested VM communication\n\n    // Store things during parsing to be processed afterwards,\n    // because we want to have created all bindings before\n    // observing values / parsing dependencies.\n    var observables = compiler.observables = [],\n        computed    = compiler.computed    = []\n\n    // prototypal inheritance of bindings\n    var parent = compiler.parentCompiler\n    compiler.bindings = parent\n        ? Object.create(parent.bindings)\n        : makeHash()\n    compiler.rootCompiler = parent\n        ? getRoot(parent)\n        : compiler\n\n    // set parent VM\n    // and register child id on parent\n    var childId = utils.attr(el, 'id')\n    if (parent) {\n        def(vm, '$parent', parent.vm)\n        if (childId) {\n            compiler.childId = childId\n            parent.vm.$[childId] = vm\n        }\n    }\n\n    // setup observer\n    compiler.setupObserver()\n\n    // call user init. this will capture some initial values.\n    if (options.init) {\n        options.init.apply(vm, options.args || [])\n    }\n\n    // create bindings for keys set on the vm by the user\n    var key, keyPrefix\n    for (key in vm) {\n        keyPrefix = key.charAt(0)\n        if (keyPrefix !== '$' && keyPrefix !== '_') {\n            compiler.createBinding(key)\n        }\n    }\n\n    // for repeated items, create an index binding\n    // which should be inenumerable but configurable\n    if (compiler.repeat) {\n        vm.$index = compiler.repeatIndex\n        def(vm, '$collection', compiler.repeatCollection)\n        compiler.createBinding('$index')\n    }\n\n    // now parse the DOM, during which we will create necessary bindings\n    // and bind the parsed directives\n    compiler.compile(el, true)\n\n    // observe root values so that they emit events when\n    // their nested values change (for an Object)\n    // or when they mutate (for an Array)\n    var i = observables.length, binding\n    while (i--) {\n        binding = observables[i]\n        Observer.observe(binding.value, binding.key, compiler.observer)\n    }\n    // extract dependencies for computed properties\n    if (computed.length) DepsParser.parse(computed)\n\n    // done!\n    compiler.init = false\n}\n\nvar CompilerProto = Compiler.prototype\n\n/**\n *  Initialize the VM/Compiler's element.\n *  Fill it in with the template if necessary.\n */\nCompilerProto.setupElement = function (options) {\n    // create the node first\n    var el = this.el = typeof options.el === 'string'\n        ? document.querySelector(options.el)\n        : options.el || document.createElement(options.tagName || 'div')\n\n    var template = options.template\n    if (template) {\n        // replace option: use the first node in\n        // the template directly\n        if (options.replace && template.childNodes.length === 1) {\n            var replacer = template.childNodes[0].cloneNode(true)\n            if (el.parentNode) {\n                el.parentNode.insertBefore(replacer, el)\n                el.parentNode.removeChild(el)\n            }\n            el = replacer\n        } else {\n            el.innerHTML = ''\n            el.appendChild(template.cloneNode(true))\n        }\n    }\n\n    // apply element options\n    if (options.id) el.id = options.id\n    if (options.className) el.className = options.className\n    var attrs = options.attributes\n    if (attrs) {\n        for (var attr in attrs) {\n            el.setAttribute(attr, attrs[attr])\n        }\n    }\n\n    return el\n}\n\n/**\n *  Setup observer.\n *  The observer listens for get/set/mutate events on all VM\n *  values/objects and trigger corresponding binding updates.\n */\nCompilerProto.setupObserver = function () {\n\n    var compiler = this,\n        bindings = compiler.bindings,\n        observer = compiler.observer = new Emitter()\n\n    // a hash to hold event proxies for each root level key\n    // so they can be referenced and removed later\n    observer.proxies = makeHash()\n\n    // add own listeners which trigger binding updates\n    observer\n        .on('get', function (key) {\n            check(key)\n            depsOb.emit('get', bindings[key])\n        })\n        .on('set', function (key, val) {\n            observer.emit('change:' + key, val)\n            check(key)\n            bindings[key].update(val)\n        })\n        .on('mutate', function (key, val, mutation) {\n            observer.emit('change:' + key, val, mutation)\n            check(key)\n            bindings[key].pub()\n        })\n\n    function check (key) {\n        if (!bindings[key]) {\n            compiler.createBinding(key)\n        }\n    }\n}\n\n/**\n *  Compile a DOM node (recursive)\n */\nCompilerProto.compile = function (node, root) {\n\n    var compiler = this\n\n    if (node.nodeType === 1) { // a normal node\n\n        // skip anything with v-pre\n        if (utils.attr(node, 'pre') !== null) return\n\n        // special attributes to check\n        var repeatExp,\n            componentId,\n            partialId,\n            customElementFn = compiler.getOption('elements', node.tagName.toLowerCase())\n\n        // It is important that we access these attributes\n        // procedurally because the order matters.\n        //\n        // `utils.attr` removes the attribute once it gets the\n        // value, so we should not access them all at once.\n\n        // v-repeat has the highest priority\n        // and we need to preserve all other attributes for it.\n        /* jshint boss: true */\n        if (repeatExp = utils.attr(node, 'repeat')) {\n\n            // repeat block cannot have v-id at the same time.\n            var directive = Directive.parse(config.attrs.repeat, repeatExp, compiler, node)\n            if (directive) {\n                compiler.bindDirective(directive)\n            }\n\n        // custom elements has 2nd highest priority\n        } else if (!root && customElementFn) {\n\n            addChild(customElementFn)\n\n        // v-component has 3rd highest priority\n        } else if (!root && (componentId = utils.attr(node, 'component'))) {\n\n            var ChildVM = compiler.getOption('components', componentId)\n            if (ChildVM) addChild(ChildVM)\n\n        } else {\n\n            // check transition property\n            node.vue_trans = utils.attr(node, 'transition')\n            \n            // replace innerHTML with partial\n            partialId = utils.attr(node, 'partial')\n            if (partialId) {\n                var partial = compiler.getOption('partials', partialId)\n                if (partial) {\n                    node.innerHTML = ''\n                    node.appendChild(partial.cloneNode(true))\n                }\n            }\n\n            // finally, only normal directives left!\n            compiler.compileNode(node)\n        }\n\n    } else if (node.nodeType === 3) { // text node\n\n        compiler.compileTextNode(node)\n\n    }\n\n    function addChild (Ctor) {\n        if (utils.isConstructor(Ctor)) {\n            var child = new Ctor({\n                el: node,\n                child: true,\n                compilerOptions: {\n                    parentCompiler: compiler\n                }\n            })\n            compiler.childCompilers.push(child.$compiler)\n        } else {\n            // simply call the function\n            Ctor(node)\n        }\n    }\n}\n\n/**\n *  Compile a normal node\n */\nCompilerProto.compileNode = function (node) {\n    var i, j, attrs = node.attributes\n    // parse if has attributes\n    if (attrs && attrs.length) {\n        var attr, valid, exps, exp\n        // loop through all attributes\n        i = attrs.length\n        while (i--) {\n            attr = attrs[i]\n            valid = false\n            exps = Directive.split(attr.value)\n            // loop through clauses (separated by \",\")\n            // inside each attribute\n            j = exps.length\n            while (j--) {\n                exp = exps[j]\n                var directive = Directive.parse(attr.name, exp, this, node)\n                if (directive) {\n                    valid = true\n                    this.bindDirective(directive)\n                }\n            }\n            if (valid) node.removeAttribute(attr.name)\n        }\n    }\n    // recursively compile childNodes\n    if (node.childNodes.length) {\n        var nodes = slice.call(node.childNodes)\n        for (i = 0, j = nodes.length; i < j; i++) {\n            this.compile(nodes[i])\n        }\n    }\n}\n\n/**\n *  Compile a text node\n */\nCompilerProto.compileTextNode = function (node) {\n    var tokens = TextParser.parse(node.nodeValue)\n    if (!tokens) return\n    var dirname = config.attrs.text,\n        el, token, directive\n    for (var i = 0, l = tokens.length; i < l; i++) {\n        token = tokens[i]\n        if (token.key) { // a binding\n            if (token.key.charAt(0) === '>') { // a partial\n                var partialId = token.key.slice(1).trim(),\n                    partial = this.getOption('partials', partialId)\n                if (partial) {\n                    el = partial.cloneNode(true)\n                    this.compileNode(el)\n                }\n            } else { // a binding\n                el = document.createTextNode('')\n                directive = Directive.parse(dirname, token.key, this, el)\n                if (directive) {\n                    this.bindDirective(directive)\n                }\n            }\n        } else { // a plain string\n            el = document.createTextNode(token)\n        }\n        node.parentNode.insertBefore(el, node)\n    }\n    node.parentNode.removeChild(node)\n}\n\n/**\n *  Add a directive instance to the correct binding & viewmodel\n */\nCompilerProto.bindDirective = function (directive) {\n\n    // keep track of it so we can unbind() later\n    this.dirs.push(directive)\n\n    // for a simple directive, simply call its bind() or _update()\n    // and we're done.\n    if (directive.isSimple) {\n        if (directive.bind) directive.bind()\n        return\n    }\n\n    // otherwise, we got more work to do...\n    var binding,\n        compiler      = this,\n        key           = directive.key,\n        baseKey       = key.split('.')[0],\n        ownerCompiler = traceOwnerCompiler(directive, compiler)\n\n    if (directive.isExp) {\n        // expression bindings are always created on current compiler\n        binding = compiler.createBinding(key, true, directive.isFn)\n    } else if (ownerCompiler.vm.hasOwnProperty(baseKey)) {\n        // If the directive's owner compiler's VM has the key,\n        // it belongs there. Create the binding if it's not already\n        // created, and return it.\n        binding = hasOwn.call(ownerCompiler.bindings, key)\n            ? ownerCompiler.bindings[key]\n            : ownerCompiler.createBinding(key)\n    } else {\n        // due to prototypal inheritance of bindings, if a key doesn't exist\n        // on the owner compiler's VM, then it doesn't exist in the whole\n        // prototype chain. In this case we create the new binding at the root level.\n        binding = ownerCompiler.bindings[key] || compiler.rootCompiler.createBinding(key)\n    }\n\n    binding.instances.push(directive)\n    directive.binding = binding\n\n    var value = binding.value\n    // invoke bind hook if exists\n    if (directive.bind) {\n        directive.bind(value)\n    }\n\n    // set initial value\n    if (value !== undefined) {\n        if (binding.isComputed) {\n            directive.refresh(value)\n        } else {\n            directive.update(value, true)\n        }\n    }\n}\n\n/**\n *  Create binding and attach getter/setter for a key to the viewmodel object\n */\nCompilerProto.createBinding = function (key, isExp, isFn) {\n\n    var compiler = this,\n        bindings = compiler.bindings,\n        binding  = new Binding(compiler, key, isExp, isFn)\n\n    if (isExp) {\n        // a complex expression binding\n        // we need to generate an anonymous computed property for it\n        var getter = ExpParser.parse(key, compiler)\n        if (getter) {\n            log('  created expression binding: ' + key)\n            binding.value = isFn\n                ? getter\n                : { $get: getter }\n            compiler.markComputed(binding)\n            compiler.exps.push(binding)\n        }\n    } else {\n        log('  created binding: ' + key)\n        bindings[key] = binding\n        // make sure the key exists in the object so it can be observed\n        // by the Observer!\n        Observer.ensurePath(compiler.vm, key)\n        if (binding.root) {\n            // this is a root level binding. we need to define getter/setters for it.\n            compiler.define(key, binding)\n        } else {\n            var parentKey = key.slice(0, key.lastIndexOf('.'))\n            if (!hasOwn.call(bindings, parentKey)) {\n                // this is a nested value binding, but the binding for its parent\n                // has not been created yet. We better create that one too.\n                compiler.createBinding(parentKey)\n            }\n        }\n    }\n    return binding\n}\n\n/**\n *  Defines the getter/setter for a root-level binding on the VM\n *  and observe the initial value\n */\nCompilerProto.define = function (key, binding) {\n\n    log('    defined root binding: ' + key)\n\n    var compiler = this,\n        vm = compiler.vm,\n        ob = compiler.observer,\n        value = binding.value = vm[key], // save the value before redefinening it\n        type = utils.typeOf(value)\n\n    if (type === 'Object' && value.$get) {\n        // computed property\n        compiler.markComputed(binding)\n    } else if (type === 'Object' || type === 'Array') {\n        // observe objects later, becase there might be more keys\n        // to be added to it. we also want to emit all the set events\n        // after all values are available.\n        compiler.observables.push(binding)\n    }\n\n    Object.defineProperty(vm, key, {\n        enumerable: true,\n        get: function () {\n            var value = binding.value\n            if (depsOb.active && (!binding.isComputed && (!value || !value.__observer__)) ||\n                Array.isArray(value)) {\n                // only emit non-computed, non-observed (primitive) values, or Arrays.\n                // because these are the cleanest dependencies\n                ob.emit('get', key)\n            }\n            return binding.isComputed\n                ? value.$get()\n                : value\n        },\n        set: function (newVal) {\n            var value = binding.value\n            if (binding.isComputed) {\n                if (value.$set) {\n                    value.$set(newVal)\n                }\n            } else if (newVal !== value) {\n                // unwatch the old value\n                Observer.unobserve(value, key, ob)\n                // set new value\n                binding.value = newVal\n                ob.emit('set', key, newVal)\n                Observer.ensurePaths(key, newVal, compiler.bindings)\n                // now watch the new value, which in turn emits 'set'\n                // for all its nested values\n                Observer.observe(newVal, key, ob)\n            }\n        }\n    })\n}\n\n/**\n *  Process a computed property binding\n */\nCompilerProto.markComputed = function (binding) {\n    var value = binding.value,\n        vm    = this.vm\n    binding.isComputed = true\n    // bind the accessors to the vm\n    if (binding.isFn) {\n        binding.value = utils.bind(value, vm)\n    } else {\n        value.$get = utils.bind(value.$get, vm)\n        if (value.$set) {\n            value.$set = utils.bind(value.$set, vm)\n        }\n    }\n    // keep track for dep parsing later\n    this.computed.push(binding)\n}\n\n/**\n *  Retrive an option from the compiler\n */\nCompilerProto.getOption = function (type, id) {\n    var opts = this.options\n    return (opts[type] && opts[type][id]) || (utils[type] && utils[type][id])\n}\n\n/**\n *  Unbind and remove element\n */\nCompilerProto.destroy = function () {\n\n    var compiler = this,\n        i, key, dir, instances, binding,\n        el         = compiler.el,\n        directives = compiler.dirs,\n        exps       = compiler.exps,\n        bindings   = compiler.bindings,\n        teardown   = compiler.options.teardown\n\n    // call user teardown first\n    if (teardown) teardown()\n\n    // unwatch\n    compiler.observer.off()\n    compiler.emitter.off()\n\n    // unbind all direcitves\n    i = directives.length\n    while (i--) {\n        dir = directives[i]\n        // if this directive is an instance of an external binding\n        // e.g. a directive that refers to a variable on the parent VM\n        // we need to remove it from that binding's instances\n        if (!dir.isSimple && dir.binding.compiler !== compiler) {\n            instances = dir.binding.instances\n            if (instances) instances.splice(instances.indexOf(dir), 1)\n        }\n        dir.unbind()\n    }\n\n    // unbind all expressions (anonymous bindings)\n    i = exps.length\n    while (i--) {\n        exps[i].unbind()\n    }\n\n    // unbind/unobserve all own bindings\n    for (key in bindings) {\n        if (hasOwn.call(bindings, key)) {\n            binding = bindings[key]\n            if (binding.root) {\n                Observer.unobserve(binding.value, binding.key, compiler.observer)\n            }\n            binding.unbind()\n        }\n    }\n\n    // remove self from parentCompiler\n    var parent = compiler.parentCompiler,\n        childId = compiler.childId\n    if (parent) {\n        parent.childCompilers.splice(parent.childCompilers.indexOf(compiler), 1)\n        if (childId) {\n            delete parent.vm.$[childId]\n        }\n    }\n\n    // finally remove dom element\n    if (el === document.body) {\n        el.innerHTML = ''\n    } else if (el.parentNode) {\n        transition(el, -1, function () {\n            el.parentNode.removeChild(el)\n        }, this)\n    }\n}\n\n// Helpers --------------------------------------------------------------------\n\n/**\n *  determine which viewmodel a key belongs to based on nesting symbols\n */\nfunction traceOwnerCompiler (key, compiler) {\n    if (key.nesting) {\n        var levels = key.nesting\n        while (compiler.parentCompiler && levels--) {\n            compiler = compiler.parentCompiler\n        }\n    } else if (key.root) {\n        while (compiler.parentCompiler) {\n            compiler = compiler.parentCompiler\n        }\n    }\n    return compiler\n}\n\n/**\n *  shorthand for getting root compiler\n */\nfunction getRoot (compiler) {\n    return traceOwnerCompiler({ root: true }, compiler)\n}\n\nmodule.exports = Compiler\n\n//# sourceURL=webpack:///./src/compiler.js?");

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n\n    prefix      : 'v',\n    debug       : false,\n    silent      : false,\n    enterClass  : 'v-enter',\n    leaveClass  : 'v-leave',\n    attrs       : {}\n    \n}\n\n//# sourceURL=webpack:///./src/config.js?");

/***/ }),

/***/ "./src/deps-parser.js":
/*!****************************!*\
  !*** ./src/deps-parser.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Emitter  = __webpack_require__(/*! ./emitter */ \"./src/emitter.js\"),\n    utils    = __webpack_require__(/*! ./utils */ \"./src/utils.js\"),\n    observer = new Emitter()\n\n/**\n *  Auto-extract the dependencies of a computed property\n *  by recording the getters triggered when evaluating it.\n */\nfunction catchDeps (binding) {\n    if (binding.isFn) return\n    utils.log('\\n─ ' + binding.key)\n    var depsHash = utils.hash()\n    observer.on('get', function (dep) {\n        if (depsHash[dep.key]) return\n        depsHash[dep.key] = 1\n        utils.log('  └─ ' + dep.key)\n        binding.deps.push(dep)\n        dep.subs.push(binding)\n    })\n    binding.value.$get()\n    observer.off('get')\n}\n\nmodule.exports = {\n\n    /**\n     *  the observer that catches events triggered by getters\n     */\n    observer: observer,\n\n    /**\n     *  parse a list of computed property bindings\n     */\n    parse: function (bindings) {\n        utils.log('\\nparsing dependencies...')\n        observer.active = true\n        bindings.forEach(catchDeps)\n        observer.active = false\n        utils.log('\\ndone.')\n    }\n    \n}\n\n//# sourceURL=webpack:///./src/deps-parser.js?");

/***/ }),

/***/ "./src/directive.js":
/*!**************************!*\
  !*** ./src/directive.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var config     = __webpack_require__(/*! ./config */ \"./src/config.js\"),\n    utils      = __webpack_require__(/*! ./utils */ \"./src/utils.js\"),\n    directives = __webpack_require__(/*! ./directives */ \"./src/directives/index.js\"),\n    filters    = __webpack_require__(/*! ./filters */ \"./src/filters.js\"),\n\n    // Regexes!\n\n    // regex to split multiple directive expressions\n    // split by commas, but ignore commas within quotes, parens and escapes.\n    SPLIT_RE        = /(?:['\"](?:\\\\.|[^'\"])*['\"]|\\((?:\\\\.|[^\\)])*\\)|\\\\.|[^,])+/g,\n\n    // match up to the first single pipe, ignore those within quotes.\n    KEY_RE          = /^(?:['\"](?:\\\\.|[^'\"])*['\"]|\\\\.|[^\\|]|\\|\\|)+/,\n\n    ARG_RE          = /^([\\w- ]+):(.+)$/,\n    FILTERS_RE      = /\\|[^\\|]+/g,\n    FILTER_TOKEN_RE = /[^\\s']+|'[^']+'/g,\n    NESTING_RE      = /^\\^+/,\n    SINGLE_VAR_RE   = /^[\\w\\.\\$]+$/\n\n/**\n *  Directive class\n *  represents a single directive instance in the DOM\n */\nfunction Directive (definition, expression, rawKey, compiler, node) {\n\n    this.compiler = compiler\n    this.vm       = compiler.vm\n    this.el       = node\n\n    var isSimple  = expression === ''\n\n    // mix in properties from the directive definition\n    if (typeof definition === 'function') {\n        this[isSimple ? 'bind' : '_update'] = definition\n    } else {\n        for (var prop in definition) {\n            if (prop === 'unbind' || prop === 'update') {\n                this['_' + prop] = definition[prop]\n            } else {\n                this[prop] = definition[prop]\n            }\n        }\n    }\n\n    // empty expression, we're done.\n    if (isSimple) {\n        this.isSimple = true\n        return\n    }\n\n    this.expression = expression.trim()\n    this.rawKey     = rawKey\n    \n    parseKey(this, rawKey)\n\n    this.isExp = !SINGLE_VAR_RE.test(this.key)\n    \n    var filterExps = this.expression.slice(rawKey.length).match(FILTERS_RE)\n    if (filterExps) {\n        this.filters = []\n        var i = 0, l = filterExps.length, filter\n        for (; i < l; i++) {\n            filter = parseFilter(filterExps[i], this.compiler)\n            if (filter) this.filters.push(filter)\n        }\n        if (!this.filters.length) this.filters = null\n    } else {\n        this.filters = null\n    }\n}\n\nvar DirProto = Directive.prototype\n\n/**\n *  parse a key, extract argument and nesting/root info\n */\nfunction parseKey (dir, rawKey) {\n\n    var key = rawKey\n    if (rawKey.indexOf(':') > -1) {\n        var argMatch = rawKey.match(ARG_RE)\n        key = argMatch\n            ? argMatch[2].trim()\n            : key\n        dir.arg = argMatch\n            ? argMatch[1].trim()\n            : null\n    }\n\n    // nesting\n    var firstChar = key.charAt(0)\n    dir.root = firstChar === '*'\n    dir.nesting = firstChar === '^'\n        ? key.match(NESTING_RE)[0].length\n        : false\n\n    if (dir.nesting) {\n        key = key.slice(dir.nesting)\n    } else if (dir.root) {\n        key = key.slice(1)\n    }\n\n    dir.key = key\n}\n\n/**\n *  parse a filter expression\n */\nfunction parseFilter (filter, compiler) {\n\n    var tokens = filter.slice(1).match(FILTER_TOKEN_RE)\n    if (!tokens) return\n    tokens = tokens.map(function (token) {\n        return token.replace(/'/g, '').trim()\n    })\n\n    var name = tokens[0],\n        apply = compiler.getOption('filters', name) || filters[name]\n    if (!apply) {\n        utils.warn('Unknown filter: ' + name)\n        return\n    }\n\n    return {\n        name  : name,\n        apply : apply,\n        args  : tokens.length > 1\n                ? tokens.slice(1)\n                : null\n    }\n}\n\n/**\n *  called when a new value is set \n *  for computed properties, this will only be called once\n *  during initialization.\n */\nDirProto.update = function (value, init) {\n    if (!init && value === this.value) return\n    this.value = value\n    this.apply(value)\n}\n\n/**\n *  -- computed property only --\n *  called when a dependency has changed\n */\nDirProto.refresh = function (value) {\n    // pass element and viewmodel info to the getter\n    // enables context-aware bindings\n    if (value) this.value = value\n\n    if (this.isFn) {\n        value = this.value\n    } else {\n        value = this.value.$get()\n        if (value !== undefined && value === this.computedValue) return\n        this.computedValue = value\n    }\n    this.apply(value)\n}\n\n/**\n *  Actually invoking the _update from the directive's definition\n */\nDirProto.apply = function (value) {\n    this._update(\n        this.filters\n            ? this.applyFilters(value)\n            : value\n    )\n}\n\n/**\n *  pipe the value through filters\n */\nDirProto.applyFilters = function (value) {\n    var filtered = value, filter\n    for (var i = 0, l = this.filters.length; i < l; i++) {\n        filter = this.filters[i]\n        filtered = filter.apply.call(this.vm, filtered, filter.args)\n    }\n    return filtered\n}\n\n/**\n *  Unbind diretive\n *  @ param {Boolean} update\n *    Sometimes we call unbind before an update (i.e. not destroy)\n *    just to teardown previous stuff, in that case we do not want\n *    to null everything.\n */\nDirProto.unbind = function (update) {\n    // this can be called before the el is even assigned...\n    if (!this.el) return\n    if (this._unbind) this._unbind(update)\n    if (!update) this.vm = this.el = this.binding = this.compiler = null\n}\n\n// exposed methods ------------------------------------------------------------\n\n/**\n *  split a unquoted-comma separated expression into\n *  multiple clauses\n */\nDirective.split = function (exp) {\n    return exp.indexOf(',') > -1\n        ? exp.match(SPLIT_RE) || ['']\n        : [exp]\n}\n\n/**\n *  make sure the directive and expression is valid\n *  before we create an instance\n */\nDirective.parse = function (dirname, expression, compiler, node) {\n\n    var prefix = config.prefix + '-'\n    if (dirname.indexOf(prefix) !== 0) return\n    dirname = dirname.slice(prefix.length)\n\n    var dir = compiler.getOption('directives', dirname) || directives[dirname]\n    if (!dir) return utils.warn('unknown directive: ' + dirname)\n\n    var rawKey\n    if (expression.indexOf('|') > -1) {\n        var keyMatch = expression.match(KEY_RE)\n        if (keyMatch) {\n            rawKey = keyMatch[0].trim()\n        }\n    } else {\n        rawKey = expression.trim()\n    }\n    \n    // have a valid raw key, or be an empty directive\n    return (rawKey || expression === '')\n        ? new Directive(dir, expression, rawKey, compiler, node)\n        : utils.warn('invalid directive expression: ' + expression)\n}\n\nmodule.exports = Directive\n\n//# sourceURL=webpack:///./src/directive.js?");

/***/ }),

/***/ "./src/directives/if.js":
/*!******************************!*\
  !*** ./src/directives/if.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var config = __webpack_require__(/*! ../config */ \"./src/config.js\"),\n    transition = __webpack_require__(/*! ../transition */ \"./src/transition.js\")\n\nmodule.exports = {\n\n    bind: function () {\n        this.parent = this.el.parentNode\n        this.ref = document.createComment(config.prefix + '-if-' + this.key)\n        this.el.vue_ref = this.ref\n    },\n\n    update: function (value) {\n\n        var el       = this.el\n\n        if (!this.parent) { // the node was detached when bound\n            if (!el.parentNode) {\n                return\n            } else {\n                this.parent = el.parentNode\n            }\n        }\n\n        // should always have this.parent if we reach here\n        var parent   = this.parent,\n            ref      = this.ref,\n            compiler = this.compiler\n\n        if (!value) {\n            transition(el, -1, remove, compiler)\n        } else {\n            transition(el, 1, insert, compiler)\n        }\n\n        function remove () {\n            if (!el.parentNode) return\n            // insert the reference node\n            var next = el.nextSibling\n            if (next) {\n                parent.insertBefore(ref, next)\n            } else {\n                parent.appendChild(ref)\n            }\n            parent.removeChild(el)\n        }\n\n        function insert () {\n            if (el.parentNode) return\n            parent.insertBefore(el, ref)\n            parent.removeChild(ref)\n        }\n    },\n\n    unbind: function () {\n        this.el.vue_ref = null\n    }\n}\n\n//# sourceURL=webpack:///./src/directives/if.js?");

/***/ }),

/***/ "./src/directives/index.js":
/*!*********************************!*\
  !*** ./src/directives/index.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils      = __webpack_require__(/*! ../utils */ \"./src/utils.js\"),\n    transition = __webpack_require__(/*! ../transition */ \"./src/transition.js\")\n\nmodule.exports = {\n\n    on     : __webpack_require__(/*! ./on */ \"./src/directives/on.js\"),\n    repeat : __webpack_require__(/*! ./repeat */ \"./src/directives/repeat.js\"),\n    model  : __webpack_require__(/*! ./model */ \"./src/directives/model.js\"),\n    'if'   : __webpack_require__(/*! ./if */ \"./src/directives/if.js\"),\n\n    attr: function (value) {\n        this.el.setAttribute(this.arg, value)\n    },\n\n    text: function (value) {\n        this.el.textContent = utils.toText(value)\n    },\n\n    html: function (value) {\n        this.el.innerHTML = utils.toText(value)\n    },\n\n    visible: function (value) {\n        this.el.style.visibility = value ? '' : 'hidden'\n    },\n\n    show: function (value) {\n        var el = this.el,\n            target = value ? '' : 'none',\n            change = function () {\n                el.style.display = target\n            }\n        transition(el, value ? 1 : -1, change, this.compiler)\n    },\n\n    'class': function (value) {\n        if (this.arg) {\n            this.el.classList[value ? 'add' : 'remove'](this.arg)\n        } else {\n            if (this.lastVal) {\n                this.el.classList.remove(this.lastVal)\n            }\n            if (value) {\n                this.el.classList.add(value)\n                this.lastVal = value\n            }\n        }\n    },\n\n    style: {\n        bind: function () {\n            this.arg = convertCSSProperty(this.arg)\n        },\n        update: function (value) {\n            this.el.style[this.arg] = value\n        }\n    }\n}\n\n/**\n *  convert hyphen style CSS property to Camel style\n */\nvar CONVERT_RE = /-(.)/g\nfunction convertCSSProperty (prop) {\n    if (prop.charAt(0) === '-') prop = prop.slice(1)\n    return prop.replace(CONVERT_RE, function (m, char) {\n        return char.toUpperCase()\n    })\n}\n\n//# sourceURL=webpack:///./src/directives/index.js?");

/***/ }),

/***/ "./src/directives/model.js":
/*!*********************************!*\
  !*** ./src/directives/model.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\"),\n    isIE9 = navigator.userAgent.indexOf('MSIE 9.0') > 0\n\nmodule.exports = {\n\n    bind: function () {\n\n        var self = this,\n            el   = self.el,\n            type = el.type\n\n        self.lock = false\n\n        // determine what event to listen to\n        self.event =\n            (self.compiler.options.lazy ||\n            el.tagName === 'SELECT' ||\n            type === 'checkbox' ||\n            type === 'radio')\n                ? 'change'\n                : 'input'\n\n        // determin the attribute to change when updating\n        var attr = type === 'checkbox'\n            ? 'checked'\n            : 'value'\n\n        // attach listener\n        self.set = self.filters\n            ? function () {\n                // if this directive has filters\n                // we need to let the vm.$set trigger\n                // update() so filters are applied.\n                // therefore we have to record cursor position\n                // so that after vm.$set changes the input\n                // value we can put the cursor back at where it is\n                var cursorPos\n                try {\n                    cursorPos = el.selectionStart\n                } catch (e) {}\n                // `input` event has weird updating issue with\n                // International (e.g. Chinese) input methods,\n                // have to use a Timeout to hack around it...\n                setTimeout(function () {\n                    self.vm.$set(self.key, el[attr])\n                    if (cursorPos !== undefined) {\n                        el.setSelectionRange(cursorPos, cursorPos)\n                    }\n                }, 0)\n            }\n            : function () {\n                // no filters, don't let it trigger update()\n                self.lock = true\n                self.vm.$set(self.key, el[attr])\n                self.lock = false\n            }\n        el.addEventListener(self.event, self.set)\n\n        // fix shit for IE9\n        // since it doesn't fire input on backspace / del / cut\n        if (isIE9) {\n            self.onCut = function () {\n                // cut event fires before the value actually changes\n                setTimeout(function () {\n                    self.set()\n                }, 0)\n            }\n            self.onDel = function (e) {\n                if (e.keyCode === 46 || e.keyCode === 8) {\n                    self.set()\n                }\n            }\n            el.addEventListener('cut', self.onCut)\n            el.addEventListener('keyup', self.onDel)\n        }\n    },\n\n    update: function (value) {\n        if (this.lock) return\n        /* jshint eqeqeq: false */\n        var self = this,\n            el   = self.el\n        if (el.tagName === 'SELECT') { // select dropdown\n            // setting <select>'s value in IE9 doesn't work\n            var o = el.options,\n                i = o.length,\n                index = -1\n            while (i--) {\n                if (o[i].value == value) {\n                    index = i\n                    break\n                }\n            }\n            o.selectedIndex = index\n        } else if (el.type === 'radio') { // radio button\n            el.checked = value == el.value\n        } else if (el.type === 'checkbox') { // checkbox\n            el.checked = !!value\n        } else {\n            el.value = utils.toText(value)\n        }\n    },\n\n    unbind: function () {\n        this.el.removeEventListener(this.event, this.set)\n        if (isIE9) {\n            this.el.removeEventListener('cut', this.onCut)\n            this.el.removeEventListener('keyup', this.onDel)\n        }\n    }\n}\n\n//# sourceURL=webpack:///./src/directives/model.js?");

/***/ }),

/***/ "./src/directives/on.js":
/*!******************************!*\
  !*** ./src/directives/on.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ../utils */ \"./src/utils.js\")\n\nfunction delegateCheck (el, root, identifier) {\n    while (el && el !== root) {\n        if (el[identifier]) return el\n        el = el.parentNode\n    }\n}\n\nmodule.exports = {\n\n    isFn: true,\n\n    bind: function () {\n        if (this.compiler.repeat) {\n            // attach an identifier to the el\n            // so it can be matched during event delegation\n            this.el[this.expression] = true\n            // attach the owner viewmodel of this directive\n            this.el.vue_viewmodel = this.vm\n        }\n    },\n\n    update: function (handler) {\n        this.unbind(true)\n        if (typeof handler !== 'function') {\n            return utils.warn('Directive \"on\" expects a function value.')\n        }\n\n        var compiler = this.compiler,\n            event    = this.arg,\n            ownerVM  = this.binding.compiler.vm\n\n        if (compiler.repeat &&\n            // do not delegate if the repeat is combined with an extended VM\n            !this.vm.constructor.super &&\n            // blur and focus events do not bubble\n            event !== 'blur' && event !== 'focus') {\n\n            // for each blocks, delegate for better performance\n            // focus and blur events dont bubble so exclude them\n            var delegator  = compiler.delegator,\n                identifier = this.expression,\n                dHandler   = delegator.vue_dHandlers[identifier]\n\n            if (dHandler) return\n\n            // the following only gets run once for the entire each block\n            dHandler = delegator.vue_dHandlers[identifier] = function (e) {\n                var target = delegateCheck(e.target, delegator, identifier)\n                if (target) {\n                    e.el = target\n                    e.vm = target.vue_viewmodel\n                    e.item = e.vm[compiler.repeatPrefix]\n                    handler.call(ownerVM, e)\n                }\n            }\n            dHandler.event = event\n            delegator.addEventListener(event, dHandler)\n\n        } else {\n\n            // a normal, single element handler\n            var vm = this.vm\n            this.handler = function (e) {\n                e.el = e.currentTarget\n                e.vm = vm\n                if (compiler.repeat) {\n                    e.item = vm[compiler.repeatPrefix]\n                }\n                handler.call(ownerVM, e)\n            }\n            this.el.addEventListener(event, this.handler)\n\n        }\n    },\n\n    unbind: function (update) {\n        this.el.removeEventListener(this.arg, this.handler)\n        this.handler = null\n        if (!update) this.el.vue_viewmodel = null\n    }\n}\n\n//# sourceURL=webpack:///./src/directives/on.js?");

/***/ }),

/***/ "./src/directives/repeat.js":
/*!**********************************!*\
  !*** ./src/directives/repeat.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Observer   = __webpack_require__(/*! ../observer */ \"./src/observer.js\"),\n    Emitter    = __webpack_require__(/*! ../emitter */ \"./src/emitter.js\"),\n    utils      = __webpack_require__(/*! ../utils */ \"./src/utils.js\"),\n    config     = __webpack_require__(/*! ../config */ \"./src/config.js\"),\n    transition = __webpack_require__(/*! ../transition */ \"./src/transition.js\"),\n    ViewModel // lazy def to avoid circular dependency\n\n/**\n *  Mathods that perform precise DOM manipulation\n *  based on mutator method triggered\n */\nvar mutationHandlers = {\n\n    push: function (m) {\n        var i, l = m.args.length,\n            base = this.collection.length - l\n        for (i = 0; i < l; i++) {\n            this.buildItem(m.args[i], base + i)\n        }\n    },\n\n    pop: function () {\n        var vm = this.vms.pop()\n        if (vm) vm.$destroy()\n    },\n\n    unshift: function (m) {\n        var i, l = m.args.length\n        for (i = 0; i < l; i++) {\n            this.buildItem(m.args[i], i)\n        }\n    },\n\n    shift: function () {\n        var vm = this.vms.shift()\n        if (vm) vm.$destroy()\n    },\n\n    splice: function (m) {\n        var i, l,\n            index = m.args[0],\n            removed = m.args[1],\n            added = m.args.length - 2,\n            removedVMs = this.vms.splice(index, removed)\n        for (i = 0, l = removedVMs.length; i < l; i++) {\n            removedVMs[i].$destroy()\n        }\n        for (i = 0; i < added; i++) {\n            this.buildItem(m.args[i + 2], index + i)\n        }\n    },\n\n    sort: function () {\n        var key = this.arg,\n            vms = this.vms,\n            col = this.collection,\n            l = col.length,\n            sorted = new Array(l),\n            i, j, vm, data\n        for (i = 0; i < l; i++) {\n            data = col[i]\n            for (j = 0; j < l; j++) {\n                vm = vms[j]\n                if (vm[key] === data) {\n                    sorted[i] = vm\n                    break\n                }\n            }\n        }\n        for (i = 0; i < l; i++) {\n            this.container.insertBefore(sorted[i].$el, this.ref)\n        }\n        this.vms = sorted\n    },\n\n    reverse: function () {\n        var vms = this.vms\n        vms.reverse()\n        for (var i = 0, l = vms.length; i < l; i++) {\n            this.container.insertBefore(vms[i].$el, this.ref)\n        }\n    }\n}\n\nmodule.exports = {\n\n    bind: function () {\n\n        var self = this,\n            el   = self.el,\n            ctn  = self.container = el.parentNode\n\n        // extract child VM information, if any\n        ViewModel       = ViewModel || __webpack_require__(/*! ../viewmodel */ \"./src/viewmodel.js\")\n        var componentId = utils.attr(el, 'component')\n        self.ChildVM    = self.compiler.getOption('components', componentId) || ViewModel\n\n        // extract transition information\n        self.hasTrans   = el.hasAttribute(config.attrs.transition)\n\n        // create a comment node as a reference node for DOM insertions\n        self.ref = document.createComment(config.prefix + '-repeat-' + self.arg)\n        ctn.insertBefore(self.ref, el)\n        ctn.removeChild(el)\n\n        self.initiated = false\n        self.collection = null\n        self.vms = null\n        self.mutationListener = function (path, arr, mutation) {\n            self.detach()\n            var method = mutation.method\n            mutationHandlers[method].call(self, mutation)\n            if (method !== 'push' && method !== 'pop') {\n                self.updateIndexes()\n            }\n            self.retach()\n        }\n\n    },\n\n    update: function (collection) {\n\n        this.unbind(true)\n        // attach an object to container to hold handlers\n        this.container.vue_dHandlers = utils.hash()\n        // if initiating with an empty collection, we need to\n        // force a compile so that we get all the bindings for\n        // dependency extraction.\n        if (!this.initiated && (!collection || !collection.length)) {\n            this.buildItem()\n            this.initiated = true\n        }\n        collection = this.collection = collection || []\n        this.vms = []\n\n        // listen for collection mutation events\n        // the collection has been augmented during Binding.set()\n        if (!collection.__observer__) Observer.watchArray(collection, null, new Emitter())\n        collection.__observer__.on('mutate', this.mutationListener)\n\n        // create child-vms and append to DOM\n        if (collection.length) {\n            this.detach()\n            for (var i = 0, l = collection.length; i < l; i++) {\n                this.buildItem(collection[i], i)\n            }\n            this.retach()\n        }\n    },\n\n    /**\n     *  Create a new child VM from a data object\n     *  passing along compiler options indicating this\n     *  is a v-repeat item.\n     */\n    buildItem: function (data, index) {\n\n        var node    = this.el.cloneNode(true),\n            ctn     = this.container,\n            scope   = {},\n            ref, item\n\n        // append node into DOM first\n        // so v-if can get access to parentNode\n        if (data) {\n            ref = this.vms.length > index\n                ? this.vms[index].$el\n                : this.ref\n            // make sure it works with v-if\n            if (!ref.parentNode) ref = ref.vue_ref\n            // process transition info before appending\n            node.vue_trans = utils.attr(node, 'transition', true)\n            transition(node, 1, function () {\n                ctn.insertBefore(node, ref)\n            }, this.compiler)\n        }\n\n        // set data on scope and compile\n        scope[this.arg] = data || {}\n        item = new this.ChildVM({\n            el: node,\n            scope: scope,\n            compilerOptions: {\n                repeat: true,\n                repeatIndex: index,\n                repeatCollection: this.collection,\n                repeatPrefix: this.arg,\n                parentCompiler: this.compiler,\n                delegator: ctn\n            }\n        })\n\n        if (!data) {\n            // this is a forced compile for an empty collection.\n            // let's remove it...\n            item.$destroy()\n        } else {\n            this.vms.splice(index, 0, item)\n        }\n    },\n\n    /**\n     *  Update index of each item after a mutation\n     */\n    updateIndexes: function () {\n        var i = this.vms.length\n        while (i--) {\n            this.vms[i].$index = i\n        }\n    },\n\n    /**\n     *  Detach/retach the container from the DOM before mutation\n     *  so that batch DOM updates are done in-memory and faster\n     */\n    detach: function () {\n        if (this.hasTrans) return\n        var c = this.container,\n            p = this.parent = c.parentNode\n        this.next = c.nextSibling\n        if (p) p.removeChild(c)\n    },\n\n    retach: function () {\n        if (this.hasTrans) return\n        var n = this.next,\n            p = this.parent,\n            c = this.container\n        if (!p) return\n        if (n) {\n            p.insertBefore(c, n)\n        } else {\n            p.appendChild(c)\n        }\n    },\n\n    unbind: function () {\n        if (this.collection) {\n            this.collection.__observer__.off('mutate', this.mutationListener)\n            var i = this.vms.length\n            while (i--) {\n                this.vms[i].$destroy()\n            }\n        }\n        var ctn = this.container,\n            handlers = ctn.vue_dHandlers\n        for (var key in handlers) {\n            ctn.removeEventListener(handlers[key].event, handlers[key])\n        }\n        ctn.vue_dHandlers = null\n    }\n}\n\n//# sourceURL=webpack:///./src/directives/repeat.js?");

/***/ }),

/***/ "./src/emitter.js":
/*!************************!*\
  !*** ./src/emitter.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// shiv to make this work for Component, Browserify and Node at the same time.\nvar Emitter,\n    componentEmitter = 'emitter'\n\ntry {\n    // Requiring without a string literal will make browserify\n    // unable to parse the dependency, thus preventing it from\n    // stopping the compilation after a failed lookup.\n    Emitter = __webpack_require__(\"./src sync recursive\")(componentEmitter)\n} catch (e) {\n    Emitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter\n    Emitter.prototype.off = function () {\n        var method = arguments.length > 1\n            ? this.removeListener\n            : this.removeAllListeners\n        return method.apply(this, arguments)\n    }\n}\n\nmodule.exports = Emitter\n\n//# sourceURL=webpack:///./src/emitter.js?");

/***/ }),

/***/ "./src/exp-parser.js":
/*!***************************!*\
  !*** ./src/exp-parser.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\"),\n    hasOwn = Object.prototype.hasOwnProperty\n\n// Variable extraction scooped from https://github.com/RubyLouvre/avalon\n\nvar KEYWORDS =\n        // keywords\n        'break,case,catch,continue,debugger,default,delete,do,else,false' +\n        ',finally,for,function,if,in,instanceof,new,null,return,switch,this' +\n        ',throw,true,try,typeof,var,void,while,with,undefined' +\n        // reserved\n        ',abstract,boolean,byte,char,class,const,double,enum,export,extends' +\n        ',final,float,goto,implements,import,int,interface,long,native' +\n        ',package,private,protected,public,short,static,super,synchronized' +\n        ',throws,transient,volatile' +\n        // ECMA 5 - use strict\n        ',arguments,let,yield' +\n        // allow using Math in expressions\n        ',Math',\n        \n    KEYWORDS_RE = new RegExp([\"\\\\b\" + KEYWORDS.replace(/,/g, '\\\\b|\\\\b') + \"\\\\b\"].join('|'), 'g'),\n    REMOVE_RE   = /\\/\\*(?:.|\\n)*?\\*\\/|\\/\\/[^\\n]*\\n|\\/\\/[^\\n]*$|'[^']*'|\"[^\"]*\"|[\\s\\t\\n]*\\.[\\s\\t\\n]*[$\\w\\.]+/g,\n    SPLIT_RE    = /[^\\w$]+/g,\n    NUMBER_RE   = /\\b\\d[^,]*/g,\n    BOUNDARY_RE = /^,+|,+$/g\n\n/**\n *  Strip top level variable names from a snippet of JS expression\n */\nfunction getVariables (code) {\n    code = code\n        .replace(REMOVE_RE, '')\n        .replace(SPLIT_RE, ',')\n        .replace(KEYWORDS_RE, '')\n        .replace(NUMBER_RE, '')\n        .replace(BOUNDARY_RE, '')\n    return code\n        ? code.split(/,+/)\n        : []\n}\n\n/**\n *  A given path could potentially exist not on the\n *  current compiler, but up in the parent chain somewhere.\n *  This function generates an access relationship string\n *  that can be used in the getter function by walking up\n *  the parent chain to check for key existence.\n *\n *  It stops at top parent if no vm in the chain has the\n *  key. It then creates any missing bindings on the\n *  final resolved vm.\n */\nfunction getRel (path, compiler) {\n    var rel = '',\n        vm  = compiler.vm,\n        dot = path.indexOf('.'),\n        key = dot > -1\n            ? path.slice(0, dot)\n            : path\n    while (true) {\n        if (hasOwn.call(vm, key)) {\n            break\n        } else {\n            if (vm.$parent) {\n                vm = vm.$parent\n                rel += '$parent.'\n            } else {\n                break\n            }\n        }\n    }\n    compiler = vm.$compiler\n    if (\n        !hasOwn.call(compiler.bindings, path) &&\n        path.charAt(0) !== '$'\n    ) {\n        compiler.createBinding(path)\n    }\n    return rel\n}\n\n/**\n *  Create a function from a string...\n *  this looks like evil magic but since all variables are limited\n *  to the VM's scope it's actually properly sandboxed\n */\nfunction makeGetter (exp, raw) {\n    /* jshint evil: true */\n    var fn\n    try {\n        fn = new Function(exp)\n    } catch (e) {\n        utils.warn('Invalid expression: ' + raw)\n    }\n    return fn\n}\n\n/**\n *  Escape a leading dollar sign for regex construction\n */\nfunction escapeDollar (v) {\n    return v.charAt(0) === '$'\n        ? '\\\\' + v\n        : v\n}\n\nmodule.exports = {\n\n    /**\n     *  Parse and return an anonymous computed property getter function\n     *  from an arbitrary expression, together with a list of paths to be\n     *  created as bindings.\n     */\n    parse: function (exp, compiler) {\n        // extract variable names\n        var vars = getVariables(exp)\n        if (!vars.length) {\n            return makeGetter('return ' + exp, exp)\n        }\n        vars = utils.unique(vars)\n        var accessors = '',\n            // construct a regex to extract all valid variable paths\n            // ones that begin with \"$\" are particularly tricky\n            // because we can't use \\b for them\n            pathRE = new RegExp(\n                \"[^$\\\\w\\\\.](\" +\n                vars.map(escapeDollar).join('|') +\n                \")[$\\\\w\\\\.]*\\\\b\", 'g'\n            ),\n            body = ('return ' + exp).replace(pathRE, function (path) {\n                // keep track of the first char\n                var c = path.charAt(0)\n                path = path.slice(1)\n                var val = 'this.' + getRel(path, compiler) + path\n                accessors += val + ';'\n                // don't forget to put that first char back\n                return c + val\n            })\n        body = accessors + body\n        return makeGetter(body, exp)\n    }\n}\n\n//# sourceURL=webpack:///./src/exp-parser.js?");

/***/ }),

/***/ "./src/filters.js":
/*!************************!*\
  !*** ./src/filters.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var keyCodes = {\n    enter    : 13,\n    tab      : 9,\n    'delete' : 46,\n    up       : 38,\n    left     : 37,\n    right    : 39,\n    down     : 40,\n    esc      : 27\n}\n\nmodule.exports = {\n\n    /**\n     *  'abc' => 'Abc'\n     */\n    capitalize: function (value) {\n        if (!value && value !== 0) return ''\n        value = value.toString()\n        return value.charAt(0).toUpperCase() + value.slice(1)\n    },\n\n    /**\n     *  'abc' => 'ABC'\n     */\n    uppercase: function (value) {\n        return (value || value === 0)\n            ? value.toString().toUpperCase()\n            : ''\n    },\n\n    /**\n     *  'AbC' => 'abc'\n     */\n    lowercase: function (value) {\n        return (value || value === 0)\n            ? value.toString().toLowerCase()\n            : ''\n    },\n\n    /**\n     *  12345 => $12,345.00\n     */\n    currency: function (value, args) {\n        if (!value && value !== 0) return ''\n        var sign = (args && args[0]) || '$',\n            s = Math.floor(value).toString(),\n            i = s.length % 3,\n            h = i > 0 ? (s.slice(0, i) + (s.length > 3 ? ',' : '')) : '',\n            f = '.' + value.toFixed(2).slice(-2)\n        return sign + h + s.slice(i).replace(/(\\d{3})(?=\\d)/g, '$1,') + f\n    },\n\n    /**\n     *  args: an array of strings corresponding to\n     *  the single, double, triple ... forms of the word to\n     *  be pluralized. When the number to be pluralized\n     *  exceeds the length of the args, it will use the last\n     *  entry in the array.\n     *\n     *  e.g. ['single', 'double', 'triple', 'multiple']\n     */\n    pluralize: function (value, args) {\n        return args.length > 1\n            ? (args[value - 1] || args[args.length - 1])\n            : (args[value - 1] || args[0] + 's')\n    },\n\n    /**\n     *  A special filter that takes a handler function,\n     *  wraps it so it only gets triggered on specific keypresses.\n     */\n    key: function (handler, args) {\n        if (!handler) return\n        var code = keyCodes[args[0]]\n        if (!code) {\n            code = parseInt(args[0], 10)\n        }\n        return function (e) {\n            if (e.keyCode === code) {\n                handler.call(this, e)\n            }\n        }\n    }\n}\n\n//# sourceURL=webpack:///./src/filters.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var config      = __webpack_require__(/*! ./config */ \"./src/config.js\"),\n    ViewModel   = __webpack_require__(/*! ./viewmodel */ \"./src/viewmodel.js\"),\n    directives  = __webpack_require__(/*! ./directives */ \"./src/directives/index.js\"),\n    filters     = __webpack_require__(/*! ./filters */ \"./src/filters.js\"),\n    utils       = __webpack_require__(/*! ./utils */ \"./src/utils.js\")\n\n/**\n *  Set config options\n */\nViewModel.config = function (opts) {\n    if (opts) {\n        utils.extend(config, opts)\n        if (opts.prefix) updatePrefix()\n    }\n    return this\n}\n\n/**\n *  Allows user to register/retrieve a directive definition\n */\nViewModel.directive = function (id, fn) {\n    if (!fn) return directives[id]\n    directives[id] = fn\n    return this\n}\n\n/**\n *  Allows user to register/retrieve a filter function\n */\nViewModel.filter = function (id, fn) {\n    if (!fn) return filters[id]\n    filters[id] = fn\n    return this\n}\n\n/**\n *  Allows user to register/retrieve a ViewModel constructor\n */\nViewModel.component = function (id, Ctor) {\n    if (!Ctor) return utils.components[id]\n    utils.components[id] = utils.toConstructor(Ctor)\n    return this\n}\n\n/**\n *  Allows user to register/retrieve a Custom element constructor\n */\nViewModel.element = function (id, Ctor) {\n    if (!Ctor) return utils.elements[id]\n    utils.elements[id] = utils.toConstructor(Ctor)\n    return this\n}\n\n/**\n *  Allows user to register/retrieve a template partial\n */\nViewModel.partial = function (id, partial) {\n    if (!partial) return utils.partials[id]\n    utils.partials[id] = utils.toFragment(partial)\n    return this\n}\n\n/**\n *  Allows user to register/retrieve a transition definition object\n */\nViewModel.transition = function (id, transition) {\n    if (!transition) return utils.transitions[id]\n    utils.transitions[id] = transition\n    return this\n}\n\nViewModel.extend = extend\n\n/**\n *  Expose the main ViewModel class\n *  and add extend method\n */\nfunction extend (options) {\n\n    var ParentVM = this\n\n    // inherit options\n    options = inheritOptions(options, ParentVM.options, true)\n    utils.processOptions(options)\n\n    var ExtendedVM = function (opts) {\n        opts = inheritOptions(opts, options, true)\n        ParentVM.call(this, opts)\n    }\n\n    // inherit prototype props\n    var proto = ExtendedVM.prototype = Object.create(ParentVM.prototype)\n    utils.defProtected(proto, 'constructor', ExtendedVM)\n\n    // copy prototype props\n    var protoMixins = options.proto\n    if (protoMixins) {\n        for (var key in protoMixins) {\n            if (!(key in ViewModel.prototype)) {\n                proto[key] = protoMixins[key]\n            }\n        }\n    }\n\n    // allow extended VM to be further extended\n    ExtendedVM.extend = extend\n    ExtendedVM.super = ParentVM\n    ExtendedVM.options = options\n    return ExtendedVM\n}\n\n/**\n *  Inherit options\n *\n *  For options such as `scope`, `vms`, `directives`, 'partials',\n *  they should be further extended. However extending should only\n *  be done at top level.\n *  \n *  `proto` is an exception because it's handled directly on the\n *  prototype.\n *\n *  `el` is an exception because it's not allowed as an\n *  extension option, but only as an instance option.\n */\nfunction inheritOptions (child, parent, topLevel) {\n    child = child || utils.hash()\n    if (!parent) return child\n    for (var key in parent) {\n        if (key === 'el' || key === 'proto') continue\n        if (!child[key]) { // child has priority\n            child[key] = parent[key]\n        } else if (topLevel && utils.typeOf(child[key]) === 'Object') {\n            inheritOptions(child[key], parent[key], false)\n        }\n    }\n    return child\n}\n\n/**\n *  Update prefix for some special directives\n *  that are used in compilation.\n */\nvar specialAttributes = [\n    'id',\n    'pre',\n    'text',\n    'repeat',\n    'partial',\n    'component',\n    'transition'\n]\n\nfunction updatePrefix () {\n    specialAttributes.forEach(setPrefix)\n}\n\nfunction setPrefix (attr) {\n    config.attrs[attr] = config.prefix + '-' + attr\n}\nconsole.log('===========pppp')\nupdatePrefix()\nmodule.exports = window.Vue = ViewModel\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/observer.js":
/*!*************************!*\
  !*** ./src/observer.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* jshint proto:true */\n\nvar Emitter  = __webpack_require__(/*! ./emitter */ \"./src/emitter.js\"),\n    utils    = __webpack_require__(/*! ./utils */ \"./src/utils.js\"),\n    depsOb   = __webpack_require__(/*! ./deps-parser */ \"./src/deps-parser.js\").observer,\n\n    // cache methods\n    typeOf   = utils.typeOf,\n    def      = utils.defProtected,\n    slice    = Array.prototype.slice,\n\n    // Array mutation methods to wrap\n    methods  = ['push','pop','shift','unshift','splice','sort','reverse'],\n\n    // fix for IE + __proto__ problem\n    // define methods as inenumerable if __proto__ is present,\n    // otherwise enumerable so we can loop through and manually\n    // attach to array instances\n    hasProto = ({}).__proto__\n\n// The proxy prototype to replace the __proto__ of\n// an observed array\nvar ArrayProxy = Object.create(Array.prototype)\n\n// Define mutation interceptors so we can emit the mutation info\nmethods.forEach(function (method) {\n    def(ArrayProxy, method, function () {\n        var result = Array.prototype[method].apply(this, arguments)\n        this.__observer__.emit('mutate', this.__observer__.path, this, {\n            method: method,\n            args: slice.call(arguments),\n            result: result\n        })\n        return result\n    }, !hasProto)\n})\n\n// Augment it with several convenience methods\nvar extensions = {\n    remove: function (index) {\n        if (typeof index === 'function') {\n            var i = this.length,\n                removed = []\n            while (i--) {\n                if (index(this[i])) {\n                    removed.push(this.splice(i, 1)[0])\n                }\n            }\n            return removed.reverse()\n        } else {\n            if (typeof index !== 'number') {\n                index = this.indexOf(index)\n            }\n            if (index > -1) {\n                return this.splice(index, 1)[0]\n            }\n        }\n    },\n    replace: function (index, data) {\n        if (typeof index === 'function') {\n            var i = this.length,\n                replaced = [],\n                replacer\n            while (i--) {\n                replacer = index(this[i])\n                if (replacer !== undefined) {\n                    replaced.push(this.splice(i, 1, replacer)[0])\n                }\n            }\n            return replaced.reverse()\n        } else {\n            if (typeof index !== 'number') {\n                index = this.indexOf(index)\n            }\n            if (index > -1) {\n                return this.splice(index, 1, data)[0]\n            }\n        }\n    }\n}\n\nfor (var method in extensions) {\n    def(ArrayProxy, method, extensions[method], !hasProto)\n}\n\n/**\n *  Watch an object based on type\n */\nfunction watch (obj, path, observer) {\n    var type = typeOf(obj)\n    if (type === 'Object') {\n        watchObject(obj, path, observer)\n    } else if (type === 'Array') {\n        watchArray(obj, path, observer)\n    }\n}\n\n/**\n *  Watch an Object, recursive.\n */\nfunction watchObject (obj, path, observer) {\n    for (var key in obj) {\n        var keyPrefix = key.charAt(0)\n        if (keyPrefix !== '$' && keyPrefix !== '_') {\n            bind(obj, key, path, observer)\n        }\n    }\n}\n\n/**\n *  Watch an Array, overload mutation methods\n *  and add augmentations by intercepting the prototype chain\n */\nfunction watchArray (arr, path, observer) {\n    def(arr, '__observer__', observer)\n    observer.path = path\n    if (hasProto) {\n        arr.__proto__ = ArrayProxy\n    } else {\n        for (var key in ArrayProxy) {\n            def(arr, key, ArrayProxy[key])\n        }\n    }\n}\n\n/**\n *  Define accessors for a property on an Object\n *  so it emits get/set events.\n *  Then watch the value itself.\n */\nfunction bind (obj, key, path, observer) {\n    var val       = obj[key],\n        watchable = isWatchable(val),\n        values    = observer.values,\n        fullKey   = (path ? path + '.' : '') + key\n    values[fullKey] = val\n    // emit set on bind\n    // this means when an object is observed it will emit\n    // a first batch of set events.\n    observer.emit('set', fullKey, val)\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        get: function () {\n            // only emit get on tip values\n            if (depsOb.active && !watchable) {\n                observer.emit('get', fullKey)\n            }\n            return values[fullKey]\n        },\n        set: function (newVal) {\n            values[fullKey] = newVal\n            ensurePaths(key, newVal, values)\n            observer.emit('set', fullKey, newVal)\n            watch(newVal, fullKey, observer)\n        }\n    })\n    watch(val, fullKey, observer)\n}\n\n/**\n *  Check if a value is watchable\n */\nfunction isWatchable (obj) {\n    var type = typeOf(obj)\n    return type === 'Object' || type === 'Array'\n}\n\n/**\n *  When a value that is already converted is\n *  observed again by another observer, we can skip\n *  the watch conversion and simply emit set event for\n *  all of its properties.\n */\nfunction emitSet (obj, observer, set) {\n    if (typeOf(obj) === 'Array') {\n        set('length', obj.length)\n    } else {\n        var key, val, values = observer.values\n        for (key in observer.values) {\n            val = values[key]\n            set(key, val)\n        }\n    }\n}\n\n/**\n *  Sometimes when a binding is found in the template, the value might\n *  have not been set on the VM yet. To ensure computed properties and\n *  dependency extraction can work, we have to create a dummy value for\n *  any given path.\n */\nfunction ensurePaths (key, val, paths) {\n    key += '.'\n    for (var path in paths) {\n        if (!path.indexOf(key)) {\n            ensurePath(val, path.replace(key, ''))\n        }\n    }\n}\n\n/**\n *  walk along a path and make sure it can be accessed\n *  and enumerated in that object\n */\nfunction ensurePath (obj, key) {\n    if (typeOf(obj) !== 'Object') return\n    var path = key.split('.'), sec\n    for (var i = 0, d = path.length - 1; i < d; i++) {\n        sec = path[i]\n        if (!obj[sec]) obj[sec] = {}\n        obj = obj[sec]\n    }\n    if (typeOf(obj) === 'Object') {\n        sec = path[i]\n        if (!(sec in obj)) obj[sec] = undefined\n    }\n}\n\nmodule.exports = {\n\n    // used in v-repeat\n    watchArray: watchArray,\n    ensurePath: ensurePath,\n    ensurePaths: ensurePaths,\n\n    /**\n     *  Observe an object with a given path,\n     *  and proxy get/set/mutate events to the provided observer.\n     */\n    observe: function (obj, rawPath, observer) {\n        if (isWatchable(obj)) {\n            var path = rawPath + '.',\n                ob, alreadyConverted = !!obj.__observer__\n            if (!alreadyConverted) {\n                def(obj, '__observer__', new Emitter())\n            }\n            ob = obj.__observer__\n            ob.values = ob.values || utils.hash()\n            var proxies = observer.proxies[path] = {\n                get: function (key) {\n                    observer.emit('get', path + key)\n                },\n                set: function (key, val) {\n                    observer.emit('set', path + key, val)\n                },\n                mutate: function (key, val, mutation) {\n                    // if the Array is a root value\n                    // the key will be null\n                    var fixedPath = key ? path + key : rawPath\n                    observer.emit('mutate', fixedPath, val, mutation)\n                    // also emit set for Array's length when it mutates\n                    var m = mutation.method\n                    if (m !== 'sort' && m !== 'reverse') {\n                        observer.emit('set', fixedPath + '.length', val.length)\n                    }\n                }\n            }\n            ob\n                .on('get', proxies.get)\n                .on('set', proxies.set)\n                .on('mutate', proxies.mutate)\n            if (alreadyConverted) {\n                emitSet(obj, ob, proxies.set)\n            } else {\n                watch(obj, null, ob)\n            }\n        }\n    },\n\n    /**\n     *  Cancel observation, turn off the listeners.\n     */\n    unobserve: function (obj, path, observer) {\n        if (!obj || !obj.__observer__) return\n        path = path + '.'\n        var proxies = observer.proxies[path]\n        obj.__observer__\n            .off('get', proxies.get)\n            .off('set', proxies.set)\n            .off('mutate', proxies.mutate)\n        observer.proxies[path] = null\n    }\n}\n\n//# sourceURL=webpack:///./src/observer.js?");

/***/ }),

/***/ "./src/text-parser.js":
/*!****************************!*\
  !*** ./src/text-parser.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var BINDING_RE = /\\{\\{(.+?)\\}\\}/\n\nmodule.exports = {\n\n    /**\n     *  Parse a piece of text, return an array of tokens\n     */\n    parse: function (text) {\n        if (!BINDING_RE.test(text)) return null\n        var m, i, tokens = []\n        /* jshint boss: true */\n        while (m = text.match(BINDING_RE)) {\n            i = m.index\n            if (i > 0) tokens.push(text.slice(0, i))\n            tokens.push({ key: m[1].trim() })\n            text = text.slice(i + m[0].length)\n        }\n        if (text.length) tokens.push(text)\n        return tokens\n    }\n    \n}\n\n//# sourceURL=webpack:///./src/text-parser.js?");

/***/ }),

/***/ "./src/transition.js":
/*!***************************!*\
  !*** ./src/transition.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var endEvent   = sniffTransitionEndEvent(),\n    config     = __webpack_require__(/*! ./config */ \"./src/config.js\"),\n    enterClass = config.enterClass,\n    leaveClass = config.leaveClass,\n    // exit codes for testing\n    codes = {\n        CSS_E     : 1,\n        CSS_L     : 2,\n        JS_E      : 3,\n        JS_L      : 4,\n        CSS_SKIP  : -1,\n        JS_SKIP   : -2,\n        JS_SKIP_E : -3,\n        JS_SKIP_L : -4,\n        INIT      : -5,\n        SKIP      : -6\n    }\n\n/**\n *  stage:\n *    1 = enter\n *    2 = leave\n */\nvar transition = module.exports = function (el, stage, changeState, compiler) {\n\n    if (compiler.init) {\n        changeState()\n        return codes.INIT\n    }\n\n    var transitionId = el.vue_trans\n\n    if (transitionId) {\n        return applyTransitionFunctions(\n            el,\n            stage,\n            changeState,\n            transitionId,\n            compiler\n        )\n    } else if (transitionId === '') {\n        return applyTransitionClass(\n            el,\n            stage,\n            changeState\n        )\n    } else {\n        changeState()\n        return codes.SKIP\n    }\n\n}\n\ntransition.codes = codes\n\n/**\n *  Togggle a CSS class to trigger transition\n */\nfunction applyTransitionClass (el, stage, changeState) {\n\n    if (!endEvent) {\n        changeState()\n        return codes.CSS_SKIP\n    }\n\n    var classList         = el.classList,\n        lastLeaveCallback = el.vue_trans_cb\n\n    if (stage > 0) { // enter\n\n        // cancel unfinished leave transition\n        if (lastLeaveCallback) {\n            el.removeEventListener(endEvent, lastLeaveCallback)\n            el.vue_trans_cb = null\n        }\n\n        // set to hidden state before appending\n        classList.add(enterClass)\n        // append\n        changeState()\n        // force a layout so transition can be triggered\n        /* jshint unused: false */\n        var forceLayout = el.clientHeight\n        // trigger transition\n        classList.remove(enterClass)\n        return codes.CSS_E\n\n    } else { // leave\n\n        // trigger hide transition\n        classList.add(leaveClass)\n        var onEnd = function (e) {\n            if (e.target === el) {\n                el.removeEventListener(endEvent, onEnd)\n                el.vue_trans_cb = null\n                // actually remove node here\n                changeState()\n                classList.remove(leaveClass)\n            }\n        }\n        // attach transition end listener\n        el.addEventListener(endEvent, onEnd)\n        el.vue_trans_cb = onEnd\n        return codes.CSS_L\n        \n    }\n\n}\n\nfunction applyTransitionFunctions (el, stage, changeState, functionId, compiler) {\n\n    var funcs = compiler.getOption('transitions', functionId)\n    if (!funcs) {\n        changeState()\n        return codes.JS_SKIP\n    }\n\n    var enter = funcs.enter,\n        leave = funcs.leave\n\n    if (stage > 0) { // enter\n        if (typeof enter !== 'function') {\n            changeState()\n            return codes.JS_SKIP_E\n        }\n        enter(el, changeState)\n        return codes.JS_E\n    } else { // leave\n        if (typeof leave !== 'function') {\n            changeState()\n            return codes.JS_SKIP_L\n        }\n        leave(el, changeState)\n        return codes.JS_L\n    }\n\n}\n\n/**\n *  Sniff proper transition end event name\n */\nfunction sniffTransitionEndEvent () {\n    var el = document.createElement('vue'),\n        defaultEvent = 'transitionend',\n        events = {\n            'transition'       : defaultEvent,\n            'MozTransition'    : defaultEvent,\n            'WebkitTransition' : 'webkitTransitionEnd'\n        }\n    for (var name in events) {\n        if (el.style[name] !== undefined) {\n            return events[name]\n        }\n    }\n}\n\n//# sourceURL=webpack:///./src/transition.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var config    = __webpack_require__(/*! ./config */ \"./src/config.js\"),\n    attrs     = config.attrs,\n    toString  = Object.prototype.toString,\n    join      = Array.prototype.join,\n    console   = window.console,\n    ViewModel // late def\n\n/**\n *  Create a prototype-less object\n *  which is a better hash/map\n */\nfunction makeHash () {\n    return Object.create(null)\n}\n\nvar utils = module.exports = {\n\n    hash: makeHash,\n\n    // global storage for user-registered\n    // vms, partials and transitions\n    components  : makeHash(),\n    partials    : makeHash(),\n    transitions : makeHash(),\n    elements    : makeHash(),\n\n    /**\n     *  get an attribute and remove it.\n     */\n    attr: function (el, type, noRemove) {\n        var attr = attrs[type],\n            val = el.getAttribute(attr)\n        if (!noRemove && val !== null) el.removeAttribute(attr)\n        return val\n    },\n\n    /**\n     *  Define an ienumerable property\n     *  This avoids it being included in JSON.stringify\n     *  or for...in loops.\n     */\n    defProtected: function (obj, key, val, enumerable, configurable) {\n        if (obj.hasOwnProperty(key)) return\n        Object.defineProperty(obj, key, {\n            value        : val,\n            enumerable   : !!enumerable,\n            configurable : !!configurable\n        })\n    },\n\n    /**\n     *  Accurate type check\n     *  internal use only, so no need to check for NaN\n     */\n    typeOf: function (obj) {\n        return toString.call(obj).slice(8, -1)\n    },\n\n    /**\n     *  Most simple bind\n     *  enough for the usecase and fast than native bind()\n     */\n    bind: function (fn, ctx) {\n        return function (arg) {\n            return fn.call(ctx, arg)\n        }\n    },\n\n    /**\n     *  Make sure only strings and numbers are output to html\n     *  output empty string is value is not string or number\n     */\n    toText: function (value) {\n        /* jshint eqeqeq: false */\n        return (typeof value === 'string' ||\n            typeof value === 'boolean' ||\n            (typeof value === 'number' && value == value)) // deal with NaN\n            ? value\n            : ''\n    },\n\n    /**\n     *  simple extend\n     */\n    extend: function (obj, ext, protective) {\n        for (var key in ext) {\n            if (protective && obj[key]) continue\n            obj[key] = ext[key]\n        }\n    },\n\n    /**\n     *  filter an array with duplicates into uniques\n     */\n    unique: function (arr) {\n        var hash = utils.hash(),\n            i = arr.length,\n            key, res = []\n        while (i--) {\n            key = arr[i]\n            if (hash[key]) continue\n            hash[key] = 1\n            res.push(key)\n        }\n        return res\n    },\n\n    /**\n     *  Convert a string template to a dom fragment\n     */\n    toFragment: function (template) {\n        if (typeof template !== 'string') {\n            return template\n        }\n        if (template.charAt(0) === '#') {\n            var templateNode = document.getElementById(template.slice(1))\n            if (!templateNode) return\n            template = templateNode.innerHTML\n        }\n        var node = document.createElement('div'),\n            frag = document.createDocumentFragment(),\n            child\n        node.innerHTML = template.trim()\n        /* jshint boss: true */\n        while (child = node.firstChild) {\n            frag.appendChild(child)\n        }\n        return frag\n    },\n\n    /**\n     *  Convert the object to a ViewModel constructor\n     *  if it is not already one\n     */\n    toConstructor: function (obj) {\n        ViewModel = ViewModel || __webpack_require__(/*! ./viewmodel */ \"./src/viewmodel.js\")\n        return utils.typeOf(obj) === 'Object'\n            ? ViewModel.extend(obj)\n            : typeof obj === 'function'\n                ? obj\n                : null\n    },\n\n    isConstructor: function (obj) {\n        ViewModel = ViewModel || __webpack_require__(/*! ./viewmodel */ \"./src/viewmodel.js\")\n        return obj.prototype instanceof ViewModel || obj === ViewModel\n    },\n\n    /**\n     *  convert certain option values to the desired format.\n     */\n    processOptions: function (options) {\n        var components = options.components,\n            partials   = options.partials,\n            template   = options.template,\n            elements   = options.elements,\n            key\n        if (components) {\n            for (key in components) {\n                components[key] = utils.toConstructor(components[key])\n            }\n        }\n        if (elements) {\n            for (key in elements) {\n                elements[key] = utils.toConstructor(elements[key])\n            }\n        }\n        if (partials) {\n            for (key in partials) {\n                partials[key] = utils.toFragment(partials[key])\n            }\n        }\n        if (template) {\n            options.template = utils.toFragment(template)\n        }\n    },\n\n    /**\n     *  log for debugging\n     */\n    log: function () {\n        if (config.debug && console) {\n            console.log(join.call(arguments, ' '))\n        }\n    },\n    \n    /**\n     *  warnings, thrown in all cases\n     */\n    warn: function() {\n        if (!config.silent && console) {\n            console.trace()\n            console.warn(join.call(arguments, ' '))\n        }\n    }\n}\n\n//# sourceURL=webpack:///./src/utils.js?");

/***/ }),

/***/ "./src/viewmodel.js":
/*!**************************!*\
  !*** ./src/viewmodel.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Compiler = __webpack_require__(/*! ./compiler */ \"./src/compiler.js\"),\n    def      = __webpack_require__(/*! ./utils */ \"./src/utils.js\").defProtected\n\n/**\n *  ViewModel exposed to the user that holds data,\n *  computed properties, event handlers\n *  and a few reserved methods\n */\nfunction ViewModel (options) {\n    // just compile. options are passed directly to compiler\n    new Compiler(this, options)\n}\n\n// All VM prototype methods are inenumerable\n// so it can be stringified/looped through as raw data\nvar VMProto = ViewModel.prototype\n\n/**\n *  Convenience function to set an actual nested value\n *  from a flat key string. Used in directives.\n */\ndef(VMProto, '$set', function (key, value) {\n    var path = key.split('.'),\n        obj = getTargetVM(this, path)\n    if (!obj) return\n    for (var d = 0, l = path.length - 1; d < l; d++) {\n        obj = obj[path[d]]\n    }\n    obj[path[d]] = value\n})\n\n/**\n *  watch a key on the viewmodel for changes\n *  fire callback with new value\n */\ndef(VMProto, '$watch', function (key, callback) {\n    this.$compiler.observer.on('change:' + key, callback)\n})\n\n/**\n *  unwatch a key\n */\ndef(VMProto, '$unwatch', function (key, callback) {\n    // workaround here\n    // since the emitter module checks callback existence\n    // by checking the length of arguments\n    var args = ['change:' + key],\n        ob = this.$compiler.observer\n    if (callback) args.push(callback)\n    ob.off.apply(ob, args)\n})\n\n/**\n *  unbind everything, remove everything\n */\ndef(VMProto, '$destroy', function () {\n    this.$compiler.destroy()\n})\n\n/**\n *  broadcast an event to all child VMs recursively.\n */\ndef(VMProto, '$broadcast', function () {\n    var children = this.$compiler.childCompilers,\n        i = children.length,\n        child\n    while (i--) {\n        child = children[i]\n        child.emitter.emit.apply(child.emitter, arguments)\n        child.vm.$broadcast.apply(child.vm, arguments)\n    }\n})\n\n/**\n *  emit an event that propagates all the way up to parent VMs.\n */\ndef(VMProto, '$emit', function () {\n    var compiler = this.$compiler,\n        emitter = compiler.emitter,\n        parent = compiler.parentCompiler\n    emitter.emit.apply(emitter, arguments)\n    if (parent) {\n        parent.emitter.emit.apply(parent.emitter, arguments)\n        parent.vm.$emit.apply(parent.vm, arguments)\n    }\n})\n\n/**\n *  delegate on/off/once to the compiler's emitter\n */\n;['on', 'off', 'once'].forEach(function (method) {\n    def(VMProto, '$' + method, function () {\n        var emitter = this.$compiler.emitter\n        emitter[method].apply(emitter, arguments)\n    })\n})\n\n/**\n *  If a VM doesn't contain a path, go up the prototype chain\n *  to locate the ancestor that has it.\n */\nfunction getTargetVM (vm, path) {\n    var baseKey = path[0],\n        binding = vm.$compiler.bindings[baseKey]\n    return binding\n        ? binding.compiler.vm\n        : null\n}\n\nmodule.exports = ViewModel\n\n//# sourceURL=webpack:///./src/viewmodel.js?");

/***/ })

/******/ });
});